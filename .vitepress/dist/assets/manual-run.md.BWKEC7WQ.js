import{_ as a,o as t,c as r,ae as i}from"./chunks/framework.BD9pLfSD.js";const d=JSON.parse('{"title":"Manual Run","description":"","frontmatter":{},"headers":[],"relativePath":"manual-run.md","filePath":"manual-run.md"}'),o={name:"manual-run.md"};function l(n,e,s,u,p,c){return t(),r("div",null,[...e[0]||(e[0]=[i('<h1 id="manual-run" tabindex="-1">Manual Run <a class="header-anchor" href="#manual-run" aria-label="Permalink to &quot;Manual Run&quot;">​</a></h1><p>Manual Run executes your Rules against the <strong>currently open</strong> URSA approvals that are visible to your URSA session.</p><p>This is designed to be safe and predictable:</p><ul><li>Approvals are fetched live from URSA at the time you Preview/Execute.</li><li>You can only act on approvals that URSA shows you (typically limited by your approval pools).</li><li>The UI requires a Preview before you can Execute.</li></ul><h2 id="preview" tabindex="-1">Preview <a class="header-anchor" href="#preview" aria-label="Permalink to &quot;Preview&quot;">​</a></h2><p>Preview is a <strong>dry run</strong>.</p><ul><li>Fetches <strong>fresh open approvals</strong> from URSA.</li><li>URSA returns approvals that apply to your session (for example: approvals in your approval pools).</li><li>Matches each approval against your enabled Rules and proposes an action: <ul><li><strong>Approve</strong></li><li><strong>Reject</strong></li><li><strong>No-Match</strong> (no rule matched, so no action would be taken)</li></ul></li><li>Displays helpful context per approval (tenant, config, requester, current value, requested value).</li></ul><p>Preview does not change anything in URSA.</p><h2 id="execute" tabindex="-1">Execute <a class="header-anchor" href="#execute" aria-label="Permalink to &quot;Execute&quot;">​</a></h2><p>Execute performs the actual approvals/rejections in URSA.</p><p>Important behavior:</p><ul><li>The UI requires you to Preview first (Execute stays disabled until you have Preview results).</li><li>Execute fetches open approvals from URSA again at execution time, so the exact set may differ from your Preview if approvals changed.</li><li>Only approvals that match a rule (Approve/Reject) are acted on. <strong>No-Match items are skipped.</strong></li></ul><h3 id="bulk-execution-two-independent-batches" tabindex="-1">Bulk execution (two independent batches) <a class="header-anchor" href="#bulk-execution-two-independent-batches" aria-label="Permalink to &quot;Bulk execution (two independent batches)&quot;">​</a></h3><p>Execute groups matched approvals into two batches and sends them to URSA separately:</p><ul><li>An <strong>Approve</strong> batch</li><li>A <strong>Reject</strong> batch</li></ul><p>These batches execute independently. If the Approve batch fails, the Reject batch is still attempted (and vice-versa).</p><p>Each executed item is sent with a comment (typically your rule’s Reason) so the action is understandable in URSA.</p><h2 id="history" tabindex="-1">History <a class="header-anchor" href="#history" aria-label="Permalink to &quot;History&quot;">​</a></h2><p>The History page shows an audit trail of executed runs.</p><p>Notes:</p><ul><li>History is currently <strong>shared across all users</strong> of this app (it is not filtered per-user).</li><li>These actions are also visible in URSA’s own audit/history views because the approvals/rejections are executed in URSA.</li></ul><p>View recent automation runs:</p><ul><li>Run ID</li><li>Mode (currently: execute)</li><li>Status</li><li>Total items</li><li>Success / Failed count</li><li>Start time</li></ul><p>Expand a run to see per-request results including tenant type, config, pool, action, and success/failure details.</p>',24)])])}const m=a(o,[["render",l]]);export{d as __pageData,m as default};
