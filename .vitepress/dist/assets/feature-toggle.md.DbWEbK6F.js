import{_ as a,o as t,c as r,ae as o}from"./chunks/framework.BD9pLfSD.js";const c=JSON.parse('{"title":"Feature Toggle","description":"","frontmatter":{},"headers":[],"relativePath":"feature-toggle.md","filePath":"feature-toggle.md"}'),n={name:"feature-toggle.md"};function i(l,e,s,u,p,h){return t(),r("div",null,[...e[0]||(e[0]=[o('<h1 id="feature-toggle" tabindex="-1">Feature Toggle <a class="header-anchor" href="#feature-toggle" aria-label="Permalink to &quot;Feature Toggle&quot;">​</a></h1><p>Feature Toggle performs a two-step workflow: submit config change in URSA and auto-approve the resulting request.</p><h2 id="why-this-exists" tabindex="-1">Why this exists <a class="header-anchor" href="#why-this-exists" aria-label="Permalink to &quot;Why this exists&quot;">​</a></h2><p>In URSA, submitting a config change and approving the resulting request are separate steps. Even if you are the approver for that request, URSA does not “know” to automatically approve it for you — you still have to open approvals, find the matching request, and click through the approve flow.</p><p>In practice, that can be a multi-screen, ~10-click workflow. UrsaWorks reduces this to a <strong>single action</strong> by chaining the change + approval steps and returning status immediately.</p><h2 id="inputs" tabindex="-1">Inputs <a class="header-anchor" href="#inputs" aria-label="Permalink to &quot;Inputs&quot;">​</a></h2><ul><li><strong>Tenant ID</strong> (numeric)</li><li><strong>Config name</strong> (from URSA approval configs)</li><li><strong>Enable / Disable</strong> toggle</li></ul><h2 id="step-1-—-config-change" tabindex="-1">Step 1 — Config Change <a class="header-anchor" href="#step-1-—-config-change" aria-label="Permalink to &quot;Step 1 — Config Change&quot;">​</a></h2><ul><li>UrsaWorks submits a config change for the selected config</li><li>Tracks <code>from</code> and <code>to</code> values if returned</li><li>A request ID is returned if URSA created one</li></ul><h2 id="step-2-—-auto-approve" tabindex="-1">Step 2 — Auto-approve <a class="header-anchor" href="#step-2-—-auto-approve" aria-label="Permalink to &quot;Step 2 — Auto-approve&quot;">​</a></h2><ul><li>UrsaWorks searches for an <strong>open approval</strong> that matches: <ul><li>Same tenant ID</li><li>Same config name</li><li>Requested by <strong>your URSA user</strong></li></ul></li><li>If found, it auto-approves the request</li><li>If not found, the config change still stands but approval is not automatic</li></ul><p>When auto-approval is not possible (for example, URSA doesn’t return a matching open approval), you can still approve the request manually in URSA.</p><h2 id="current-state-display" tabindex="-1">Current State Display <a class="header-anchor" href="#current-state-display" aria-label="Permalink to &quot;Current State Display&quot;">​</a></h2><p>When you enter a Tenant ID, the page fetches and displays the current state of features for that tenant:</p><ul><li><strong>Enabled</strong>: Green indicator</li><li><strong>Disabled</strong>: Red indicator</li><li><strong>Unknown</strong>: Neutral styling</li></ul><h2 id="error-handling" tabindex="-1">Error Handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error Handling&quot;">​</a></h2><p>The page shows appropriate messages for:</p><ul><li>Invalid tenant ID</li><li>Feature already in requested state</li><li>Existing pending request</li><li>Auto-approval failure (config change still succeeds)</li><li>Network or session errors</li></ul><p>If auto-approval fails because no matching approval is found:</p><ul><li>If feature is already in requested state: &quot;Already enabled/disabled&quot;</li><li>If feature is not in requested state: &quot;Approval may belong to another team&quot;</li></ul>',20)])])}const d=a(n,[["render",i]]);export{c as __pageData,d as default};
